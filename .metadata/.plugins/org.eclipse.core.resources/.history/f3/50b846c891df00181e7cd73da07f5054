/*
 * MIDIparser.cpp
 *
 *  Created on: Nov 3, 2018
 *      Author: Roman
 */

#include <MIDIparser.hpp>

using namespace MIDI;

MIDIparser::MIDIparser() : running_status_(0),
		data_size_(0), expected_data_size_(0) { };

void MIDIparser::MessageReceived(uint8_t status) {
	 if (!status) {
	    //Device::BozoByte(data_[0]);
	  }

	  uint8_t hi = status & 0xf0;
	  uint8_t lo = status & 0x0f;

	  // If this is a channel-specific message, check first that the receiver is
	  // tuned to this channel.
	  if (hi != 0xf0 /*&& !Device::CheckChannel(lo)*/) {
	    //Device::RawMidiData(status, data_, data_size_, 0);
	    return;
	  }
	  if (status != 0xf0 && status != 0xf7) {
	    //Device::RawMidiData(status, data_, data_size_, 1);
	  }
	  switch (hi) {
	    case 0x80:
	     // Device::NoteOff(lo, data_[0], data_[1]);
	      break;

	    case 0x90:
	      if (data_[1]) {
	       // Device::NoteOn(lo, data_[0], data_[1]);
	      } else {
	        //Device::NoteOff(lo, data_[0], 0);
	      }
	      break;

	    case 0xa0:
	      //Device::Aftertouch(lo, data_[0], data_[1]);
	      break;

	    case 0xb0:
	      //Device::ControlChange(lo, data_[0], data_[1]);
	      break;

	    case 0xc0:
	    //  Device::ProgramChange(lo, data_[0]);
	      break;

	    case 0xd0:
	      //Device::Aftertouch(lo, data_[0]);
	      break;

	    case 0xe0:
	      //Device::PitchBend(lo, (static_cast<uint16_t>(data_[1]) << 7) + data_[0]);
	      break;

	    case 0xf0:
	      switch(lo) {
	        case 0x0:
	        //  Device::SysExByte(data_[0]);
	          break;
	        case 0x1:
	        case 0x2:
	        case 0x3:
	        case 0x4:
	        case 0x5:
	        case 0x6:
	          // TODO(pichenettes): implement this if it makes sense.
	          break;
	        case 0x8:
	          //Device::Clock();
	          break;
	        case 0x9:
	          break;
	        case 0xa:
	         // Device::Start();
	          break;
	        case 0xb:
	        //  Device::Continue();
	          break;
	        case 0xc:
	         // Device::Stop();
	          break;
	        case 0xe:
	         // Device::ActiveSensing();
	          break;
	        case 0xf:
	          //Device::Reset();
	          break;
	      }
	      break;
	  }
}

void MIDIparser::PushByte(uint8_t byte) {
	// Realtime messages are immediately passed-through, and do not modify the
	  // state of the parser.
	  //Device::RawByte(byte);
	  if (byte >= 0xf8) {//If realtime
	    MessageReceived(byte);
	  } else {
	    if (byte >= 0x80) {
	      uint8_t hi = byte & 0xf0;
	      uint8_t lo = byte & 0x0f;
	      data_size_ = 0;
	      expected_data_size_ = 1;
	      switch (hi) {
	        case NOTE_OFF:
	        case NOTE_ON:
	        case AFTERTOUCH:
	        case CONT_CONTROLLER:
	          expected_data_size_ = 2;
	          break;
	        case PATCH_CHANGE:
	        case CHANNEL_PRES:
	          break;  // default data size of 1.
	        case PITCH_BEND:
	          expected_data_size_ = 2;
	          break;
	        case SYS_EX_START:
	          if (lo > 0 && lo < 3) {
	            expected_data_size_ = 2;
	          } else if (lo >= 4) {
	            expected_data_size_ = 0;
	          }
	          break;
	      }
	      if (byte == SYS_EX_END) {
	        if (running_status_ == SYS_EX_START) {
	          //Device::SysExEnd();
	        }
	        running_status_ = 0;
	      } else if (byte == SYS_EX_START) {
	        running_status_ = SYS_EX_START;
	        //Device::SysExStart();
	      } else {
	        running_status_ = byte;
	      }
	    } else {
	      data_[data_size_++] = byte;
	    }
	    if (data_size_ >= expected_data_size_) {
	      MessageReceived(running_status_);
	      data_size_ = 0;
	      if (running_status_ > SYS_EX_START) {
	        expected_data_size_ = 0;
	        running_status_ = 0;
	      }
	    }
	  }
};
