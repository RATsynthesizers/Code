==============================================================================
-----------------------------------G I T--------------------------------------
==============================================================================
git init             - init git in curr dir

git remote           - view list of remote repos
git remote add <remote name> <remote url>   - add new remote repo 

git add <filename>   - add file to commit
git add *            - add all files in curr dir to commit (no recurs)
git add <dir name>   - add this dir and all files which are 
                       located inside this dir (recursively)
git add .            - add ALL files to commit

git commit -m "<some text>"                 - commit changes in all added files
git commit -m "<some text>" <filename>      - commit changes to specific file
git status           - check status for added files

git push <remote name> <branch name>        - push to remote repo
git pull <remote name> <branch name>        - pull from remote repo

git branch <branch name>     - create new branch
git checkout <branch name>   - switch to another branch


==============================================================================
----------------------S Y S T E M   W O R K B E N C H-------------------------
==============================================================================
*С++ проект и CubeMX:
  > Создаётся проект в CubeMX, генерится проект для SW4STM32;
  > Правый клик по проекту в дереве проекта -> convert to C++;
  > Если вместо convert to C++ появилось convert to C - конвертация прошла успешно;
  > main.c -> main.cpp;
  > Перед регеном в CubeMX переименовать обратно main.cpp -> main.c;
  > Все #include .hpp подключаются только в main.cpp, не в main.h;
  
*Добавление ссылок на сурсы из другого проекта:
  > Project->Properties->C/C++Buld->Settings->Includes - прописать относительно директории проекта
    в формате ../../OtherProjDir
   proj_folder^  ^parent_folder
  > Создать в дереве проекта Source folder, в нём обычные папки src и inc (опционально);
  > перетащить файлы из проводника, и указать create links относительно PROJECT_LOC
	ИЛИ
    src->Import->FileSystem, Advanced->Create links, relative to PROJECT_LOC, 
    указать путь и выбрать сурсы
  
*Скачивание и запуск проекта с репы:
  > В консоли GitBash при помощи команды cd идём в желаемое место
  > Делаем git clone https://github.com/RATsynthesizers/Code;
  > Открываем проект WinProj или WeirdProj, указываем workspace в папке Code;
  > Пробуем билдить. Может так случиться, что при билде исчезнет папка modules, 
    в которой хранятся ссылки .cpp и .hpp наших модулей, и он будет ругаться на 
    ненайденные сурсы. Тогда просто создаём новый Source Folder с названием modules,
    внутри две обычные папки inc и src, и в них перетаскиваем сурсы модулей 
    из WeirdProj (см. раздел *Добавление ссылок на сурсы из другого проекта)

*Обновление кода и коммиты:
  > добавляем git remote add <remote name> <remote url>,
    т.е. например git remote add cod https://github.com/RATsynthesizers/Code
    теперь cod - это наш удалённый репозиторий с кодом;
  > git add . - добавляем все файлы в отслеживание
  > В идеале надо делать отдельный коммит для каждого файла, чтобы было легче понять 
    по названию коммита, какие изменения произошли. т.е. для отдельного файла делаем 
    git commit -m "<название коммита>" <путь до файла>
  > после всех коммитов можно залить изменения на репу командой 
    git push cod master (или в другую ветку)

*Фиксы: 
  > Для Dynamic cast-ов: Project->Properties->C/C++Buld->Settings->G++ Compiler->Miscellaneous->uncheck "Disable generation of information about every class with virtual functions (-fno-rtti)";
  > Для F4 - software reset, при багах перезагрузить вендовс;



==============================================================================
---------------------------------Т Е Г И--------------------------------------
==============================================================================
??     - обратить внимание
todo   - на будущее 
?M     - изменить при добавлении нового модуля
?P     - изменить при добавлении нового параметра
?style - вопрос по стилю


==============================================================================
-------------------------C O D I N G   S T Y L E ?----------------------------
==============================================================================
<Lcase/Hcase> - любое слово, начинающееся с буквы соответсвующего регистра.
Например, имя iP<Lcase> может быть реализовано как iPfrq, а iP<Hcase> как iBptrFrq.

сокращения типов:
typedef uint8_t  u8;            // аналогично для uint16_t и uint32_t
typedef uint8_t* u8ptr;         // аналогично для uint16_t и uint32_t
typedef const uint8_t* c_u8ptr; // аналогично для uint16_t и uint32_t

Размеры всех буферов кратны размеру блоков.
Все модули имеют как минимум 1 выходной буфер.
Выходные буферы всех модулей имеют размер в 1 блок (за исключением последнего модуля, see line 34-35).
Модули имеют т.н. входные параметры - данные, используемые методом модуля для вычислений.
Вх. парам. состоит из: 1) переменной - значения, задаваемого интерфейсом (пользователем);
                          переменная имеет некоторое дефолтное значение при создании;
                       2) массива указателей на выходные буферы других блоков - за счёт этого
                          можно на вход параметра подключить несколько выходов других блоков.
                          Если эти указатели не NULL, то метод модуля для своих вычислений
                          помимо переменной использует также и буферы, на которые даны указатели.
                          Этот массив имеет ограниченный размер (например 16);
Настройка связей между модулями осуществляется при помощи классов-проводов.

Любое изменение входных параметров-переменных и связей происходит по запросу из интерфейса.
  Например, нужно задать частоту генератора 2 равную 1000. Тогда интерфейс должен обратиться
  к модулю типа генератор с номером 2, и сетнуть его параметр-переменную frq в 1000.
  Или если нужно соединить выход генератора 1 с параметром frq генератора 2, то:
    1) либо инетрфейс сам находит модули типа "генератор" 1 и 2, и прописывает указатель на выходной
    буфер ген1 во входной массив указателей параметра frq генератора 2;
    2) либо создаёт провод (если такого провода ещё нет) и даёт ему тип и номер srcModule, тип и номер dstModule,
       и входной параметр dstModule, к которому мы хотим подключить наш srcModule. А провод, в свою очередь,
       находит нужные подули по их типу и номеру, и прописывает соотв. укль в массив уклей параметра dstModule.
    3) либо хз, как лучше, я не шарю. Нужны ли нам вообще провода, если прописывать укли интерфейс может сам, да ещё
       и список связей запоминать?

Последний модуль в системе - всегда усилитель. Он задаёт общий уровень выходного сигнала.
  Он всегда есть в системе, и его выходной буфер состоит из нескольких блоков (в отличие от остальных модулей),
  т.к. непосредственно из этого буфера идёт выгрузка семплов на DAC (see line 44)
  Мы отказались от концепции модуля DAC, т.к. чтобы заполнить его большой буфер, необходимо копировать семплы
  из предыдущего маленького буфера, принадлежащего последнему модулю в системе (размеры этих буферов
  не совпадают, и скопировать по указателю не получится). Усилитель всегда выполняет последнее вычисление,
  и может сразу после этого класть результат в большой буфер, без последующей мышиной возни. Таким образом
  мы избавляемся от копирования буферов везде.
  Назовём этот последний модуль-усилитель DAC-ом, И БУДЕМ ЖИТЬ С ЭТИМ.

Работа дака и всей системы происходит следующим образом:
  У усилителя-дака есть выходной буфер, который он постепенно разгружает (это происходит в прерывании).

  Представим себе сейчас, что этот буфер из нескольких блоков полон. Начинается его посемпловая разгрузка.

  Когда дак разгрузил половину буфера и начинает разгружать вторую, ставится глобальный флаг "хочу новых семплов".
  По этому флагу все модули обновляются, т.е. для всех модулей в системе вызывается метод generate.
  Если для входных парметров модулей мы используем указатели или ссылки, то делать это
  нужно в определённом порядке, т.е. необходимо составить очередь, кто за кем обновляется.

  Если выход а подключен на вход b, то естественно а должен обновится перед обновлением b,
  чтобы b смог взять актуальные входные данные из а.

  После того, как все модули обновились, дак (при обновлении себя) кладёт итоговый блок аудио себе в большой буфер.

  Но флаг "хочу новых семплов" не снимается, пока мы не заполним половину большого буфера.
  Поэтому все модули обновляются ещё несколько раз, и когда нагенерили половину большого буфера, флаг снимается.

  И потом мы ждём, пока дак не разгрузит до конца другую половину буфера, и потом всё начинается сначала.
  Всё, что происходит в даке, делается в прерывании, и в прерывании выставляется флаг на всеобщее обновление.





