<Lcase/Hcase> - любое слово, начинающееся с буквы соответсвующего регистра.
Например, имя iP<Lcase> может быть реализовано как iPfrq, а iPptr<Hcase> как iBptrFrq.

сокращения типов:
typedef uint8_t  u8;            // аналогично для uint16_t и uint32_t
typedef uint8_t* u8ptr;         // аналогично для uint16_t и uint32_t
typedef const uint8_t* c_u8ptr; // аналогично для uint16_t и uint32_t

Размеры всех буферов кратны размеру блоков.
Все модули имеют как минимум 1 выходной буфер.
Выходные буферы всех модулей имеют размер в 1 блок (за исключением последнего модуля, see line 34-35).
Модули имеют т.н. входные параметры - данные, используемые методом модуля для вычислений.
Вх. парам. состоит из: 1) переменной - значения, задаваемого интерфейсом (пользователем);
                          переменная имеет некоторое дефолтное значение при создании;
                       2) массива указателей на выходные буферы других модулей - за счёт этого
                          можно на вход параметра подключить несколько выходов других модулей.
                          Если эти указатели не NULL, то метод модуля для своих вычислений
                          помимо переменной использует также и буферы, на которые даны указатели.
                          Этот массив имеет ограниченный размер (например 16);
Настройка связей между модулями осуществляется при помощи классов-проводов. //?

Любое изменение входных параметров-переменных и связей происходит по запросу из интерфейса.
  Например, нужно задать частоту генератора 2 равную 1000. Тогда интерфейс должен обратиться
  к модулю типа генератор с номером 2, и сетнуть его параметр-переменную frq в 1000.
  Или если нужно соединить выход генератора 1 с параметром frq генератора 2, то:
    1) либо инетрфейс сам находит модули типа "генератор" 1 и 2, и прописывает указатель на выходной
    буфер ген1 во входной массив указателей параметра frq генератора 2;
    2) либо создаёт провод (если такого провода ещё нет) и даёт ему тип и номер srcModule, тип и номер dstModule,
       и входной параметр dstModule, к которому мы хотим подключить наш srcModule. А провод, в свою очередь,
       находит нужные подули по их типу и номеру, и прописывает соотв. укль в массив уклей параметра dstModule.
    3) либо хз, как лучше, я не шарю. Нужны ли нам вообще провода, если прописывать укли интерфейс может сам, да ещё
       и список связей запоминать?

Последний модуль в системе - всегда усилитель. Он задаёт общий уровень выходного сигнала.
  Он всегда есть в системе, и его выходной буфер состоит из нескольких блоков (в отличие от остальных модулей),
  т.к. непосредственно из этого буфера идёт выгрузка семплов на DAC (see line 44)
  Мы отказались от концепции модуля DAC, т.к. чтобы заполнить его большой буфер, необходимо копировать семплы
  из предыдущего маленького буфера, принадлежащего последнему модулю в системе (размеры этих буферов
  не совпадают, и скопировать по указателю не получится). Усилитель всегда выполняет последнее вычисление,
  и может сразу после этого класть результат в большой буфер, без последующей мышиной возни. Таким образом
  мы избавляемся от копирования буферов везде.
  Назовём этот последний модуль-усилитель DAC-ом, И БУДЕМ ЖИТЬ С ЭТИМ.

Работа дака и всей системы происходит следующим образом:
  У усилителя-дака есть выходной буфер, который он постепенно разгружает (это происходит в прерывании).

  Представим себе сейчас, что этот буфер из нескольких блоков полон. Начинается его посемпловая разгрузка.

  Когда дак разгрузил половину буфера и начинает разгружать вторую, ставится глобальный флаг "хочу новых семплов".
  По этому флагу все модули обновляются, т.е. для всех модулей в системе вызывается метод generate.
  Если для входных парметров модулей мы используем указатели или ссылки, то делать это
  нужно в определённом порядке, т.е. необходимо составить очередь, кто за кем обновляется.

  Если выход а подключен на вход b, то естественно а должен обновится перед обновлением b,
  чтобы b смог взять актуальные входные данные из а.

  После того, как все модули обновились, дак (при обновлении себя) кладёт итоговый блок аудио себе в большой буфер.

  Но флаг "хочу новых семплов" не снимается, пока мы не заполним половину большого буфера.
  Поэтому все модули обновляются ещё несколько раз, и когда нагенерили половину большого буфера, флаг снимается.

  И потом мы ждём, пока дак не разгрузит до конца другую половину буфера, и потом всё начинается сначала.
  Всё, что происходит в даке, делается в прерывании, и в прерывании выставляется флаг на всеобщее обновление.


module    - вычислительное устройство, содержит:
  iP<Lcase>     - входной параметр модуля, переменная
  iBptr<Hcase>  - указатель на входной буфер параметра модуля
  oB        - выходной буфер модуля
  oBptr     - указатель на выходной буфер модуля
  update()  - метод обновления модуля

wire      - связь между модулями, содержит:
  // srcModule - ссылка на начальный модуль
  // dstModule - ссылка на конечный модуль    |=> мб это можно объединить как Module->Parameter, не знаю
  // dstParam  - ссылка на конечный параметр  |



