==============================================================================
-----------------------------------G I T--------------------------------------
==============================================================================
git init      - init git in curr dir
git remote     - view list of remote repos
git remote add <remote name> <remote url>   - add new remote repo 
git add <filename>   - add file to commit
git add .         - add all files in curr dir to to commit 
git commit -m "<some text>"   - commit changes
git status     - check status for added files
git remote push <remote name> <branch name>   - push to remote repo
git remote pull <remote name> <branch name>   - pull from remote repo


==============================================================================
-------------------------C O D I N G   S T Y L E ?----------------------------
==============================================================================
<Lcase/Hcase> - любое слово, начинающееся с буквы соответсвующего регистра.
Например, имя iP<Lcase> может быть реализовано как iPfrq, а iP<Hcase> как iBptrFrq.

сокращения типов:
typedef uint8_t  u8;            // аналогично для uint16_t и uint32_t
typedef uint8_t* u8ptr;         // аналогично для uint16_t и uint32_t
typedef const uint8_t* c_u8ptr; // аналогично для uint16_t и uint32_t

Размеры всех буферов кратны размеру блоков.
Все модули имеют как минимум 1 выходной буфер.
Выходные буферы всех модулей имеют размер в 1 блок (за исключением последнего модуля, see line 34-35).
Модули имеют т.н. входные параметры - данные, используемые методом модуля для вычислений.
Вх. парам. состоит из: 1) переменной - значения, задаваемого интерфейсом (пользователем);
                          переменная имеет некоторое дефолтное значение при создании;
                       2) массива указателей на выходные буферы других блоков - за счёт этого
                          можно на вход параметра подключить несколько выходов других блоков.
                          Если эти указатели не NULL, то метод модуля для своих вычислений
                          помимо переменной использует также и буферы, на которые даны указатели.
                          Этот массив имеет ограниченный размер (например 16);
Настройка связей между модулями осуществляется при помощи классов-проводов.

Любое изменение входных параметров-переменных и связей происходит по запросу из интерфейса.
  Например, нужно задать частоту генератора 2 равную 1000. Тогда интерфейс должен обратиться
  к модулю типа генератор с номером 2, и сетнуть его параметр-переменную frq в 1000.
  Или если нужно соединить выход генератора 1 с параметром frq генератора 2, то:
    1) либо инетрфейс сам находит модули типа "генератор" 1 и 2, и прописывает указатель на выходной
    буфер ген1 во входной массив указателей параметра frq генератора 2;
    2) либо создаёт провод (если такого провода ещё нет) и даёт ему тип и номер srcModule, тип и номер dstModule,
       и входной параметр dstModule, к которому мы хотим подключить наш srcModule. А провод, в свою очередь,
       находит нужные подули по их типу и номеру, и прописывает соотв. укль в массив уклей параметра dstModule.
    3) либо хз, как лучше, я не шарю. Нужны ли нам вообще провода, если прописывать укли интерфейс может сам, да ещё
       и список связей запоминать?

Последний модуль в системе - всегда усилитель. Он задаёт общий уровень выходного сигнала.
  Он всегда есть в системе, и его выходной буфер состоит из нескольких блоков (в отличие от остальных модулей),
  т.к. непосредственно из этого буфера идёт выгрузка семплов на DAC (see line 44)
  Мы отказались от концепции модуля DAC, т.к. чтобы заполнить его большой буфер, необходимо копировать семплы
  из предыдущего маленького буфера, принадлежащего последнему модулю в системе (размеры этих буферов
  не совпадают, и скопировать по указателю не получится). Усилитель всегда выполняет последнее вычисление,
  и может сразу после этого класть результат в большой буфер, без последующей мышиной возни. Таким образом
  мы избавляемся от копирования буферов везде.
  Назовём этот последний модуль-усилитель DAC-ом, И БУДЕМ ЖИТЬ С ЭТИМ.

Работа дака и всей системы происходит следующим образом:
  У усилителя-дака есть выходной буфер, который он постепенно разгружает (это происходит в прерывании).

  Представим себе сейчас, что этот буфер из нескольких блоков полон. Начинается его посемпловая разгрузка.

  Когда дак разгрузил половину буфера и начинает разгружать вторую, ставится глобальный флаг "хочу новых семплов".
  По этому флагу все модули обновляются, т.е. для всех модулей в системе вызывается метод generate.
  Если для входных парметров модулей мы используем указатели или ссылки, то делать это
  нужно в определённом порядке, т.е. необходимо составить очередь, кто за кем обновляется.

  Если выход а подключен на вход b, то естественно а должен обновится перед обновлением b,
  чтобы b смог взять актуальные входные данные из а.

  После того, как все модули обновились, дак (при обновлении себя) кладёт итоговый блок аудио себе в большой буфер.

  Но флаг "хочу новых семплов" не снимается, пока мы не заполним половину большого буфера.
  Поэтому все модули обновляются ещё несколько раз, и когда нагенерили половину большого буфера, флаг снимается.

  И потом мы ждём, пока дак не разгрузит до конца другую половину буфера, и потом всё начинается сначала.
  Всё, что происходит в даке, делается в прерывании, и в прерывании выставляется флаг на всеобщее обновление.





==============================================================================
----------------------S Y S T E M   W O R K B E N C H-------------------------
==============================================================================
*С++ проект и CubeMX:
  > Создаётся проект в CubeMX, генерится проект для SW4STM32;
  > Правый клик по проекту в дереве проекта -> convert to C++;
  > Если вместо convert to C++ появилось convert to C - конвертация прошла успешно;
  > main.c -> main.cpp;
  > Перед регеном в CubeMX переименовать обратно main.cpp -> main.c;
  > Все #include .hpp подключаются только в main.cpp, не в main.h;
  
*Добавление ссылок на сурсы в проект:
  > Project->Properties->C/C++Buld->Settings->Includes - прописать относительно директории проекта
    в формате ../../OtherProjDir
   proj_folder^  ^parent_folder
  > Создать в дереве проекта Source folder, в нём обычные папки src и (inc опционально);
  > src->Import->FileSystem, Advanced->Create links, relative to PROJECT_LOC, 
    указать путь и выбрать сурсы

*Фиксы: 
  > Для Dynamic cast-ов: Project->Properties->C/C++Buld->Settings->G++ Compiler->Miscellaneous->uncheck "Disable generation of information about every class with virtual functions (-fno-rtti)";
  > Для F4 - software reset, при багах перезагрузить вендовс;




==================================================с============================
---------------------------------Т Е Г И--------------------------------------
==============================================================================
??    - обратить внимание
todo  - на будущее 
?M    - изменить при добавлении нового модуля
?P    - изменить при добавлении нового параметра